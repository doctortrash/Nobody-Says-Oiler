--[[local allSums = {}
local coinAmounts = {1,2,5,10,20,50,100,200}
local coinNames = {"1p","2p","5p","10p","20p","50p","100p","200p"}
local totalNeeded = 200
local count = 0


function recurse(total,totalTable)



  if #totalTable == (#coinAmounts-1) then
    --we have reached the point of no return: were done :)
    if total == totalNeeded then
      count = count + 1
      --print(count)
    end
    return
  else
    print("else",#totalTable , #coinAmounts)

    if total <= totalNeeded then
      --we can repeat it for other things
      for rep = 0, math.ceil(totalNeeded/coinAmounts[#totalTable+1]) do
        --this is recurse repeated AGAIN
        total = total + (rep * coinAmounts[#totalTable+1])
        table.insert(totalTable,rep)


        recurse(total,totalTable)
      end
    end

  end

  --if index is #coinAmounts that means that we have calculated a possible sum, we need to do the final check to make sure it is what we need so
  --that we can add it with a specific tag generated by the coinNames table

end



for onepence = 0,200 do
  recurse(onepence,{onepence})
end[]]



local numbers = {1,2,5,10,20,50,100,200}
local names = {"1p","2p","5p","10p","20p","50p","100p","200p"}

local needed = 200
local totalCount = 0
local tb = {}

function recurse(total,current,str)

  if current == #numbers+1 then
    --it has gone through all numbers
    --print(total)
    if total == needed then

      if tb[str] == nil then
        --print(str)
        tb[str] = 0
        totalCount = totalCount + 1
      end

    end

  else
    --still needs to go
    if total <= needed then

      for rep = 0,math.ceil(needed/numbers[current]) do

        local tt = total + (rep * numbers[current])
        st = str..names[current]..tostring(rep)

        recurse(tt,current + 1,st)
      end

    end
  end


end



for t = 0,needed do
  recurse(t,2,"1p"..tostring(t))
end

print(totalCount)
